{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Page d'acceuil","text":"<p>Bienvenue sur le site du cours de services d'\u00e9changes de donn\u00e9es 420-4D2-MA du Coll\u00e8ge de Maisonneuve. Ce cours est donn\u00e9 par le professeur Vincent Archambault-Bouffard.</p>"},{"location":"#description-du-cours","title":"Description du cours","text":"<p>Ce cours aborde le d\u00e9veloppement de services d\u2019\u00e9change de donn\u00e9es qui interagissent avec diff\u00e9rents types de clients. Les formats d\u2019\u00e9change de donn\u00e9es sont pr\u00e9sent\u00e9s ainsi que les protocoles de communication utilis\u00e9s. L\u2019\u00e9tudiant d\u00e9veloppe un service qui traite des requ\u00eates de s\u00e9lection et de modification de donn\u00e9es. Il utilise des m\u00e9canismes d\u2019authentification et d\u2019autorisation pour assurer la s\u00e9curit\u00e9 des donn\u00e9es. Il expose la documentation de l\u2019interface de programmation. Il valide le fonctionnement du serveur \u00e0 l\u2019aide d\u2019un outil de test.</p>"},{"location":"#plan-de-cours","title":"Plan de cours","text":"<p>Le plan de cours officiel est disponible sur Omnivox. Pour les personnes \u00e0 l'ext\u00e9rieur du Coll\u00e8ge de Maisonneuve, les informations pertinentes sont les suivantes:</p>"},{"location":"#objectif-terminal-du-cours","title":"Objectif terminal du cours","text":"<p>\u00c0 la fin de ce cours, l'\u00e9tudiant sera en mesure d\u2019effectuer le d\u00e9veloppement de services d'\u00e9change de donn\u00e9es.</p>"},{"location":"#environnement-de-travail","title":"Environnement de travail","text":"<ul> <li>Systeme d'exploitation: Windows</li> <li>Langage utilis\u00e9: JavaScript</li> <li>Environnement de d\u00e9veloppement: VSCode (les \u00e9tudiants peuvent aussi utiliser WebStorm)</li> <li>Gestionnaire de version: Git et GitHub</li> <li>Node.js</li> <li>Navigateur Chrome</li> <li>Microsoft Word et Microsoft Excel</li> </ul>"},{"location":"#echeancier-et-evaluations","title":"\u00c9ch\u00e9ancier et \u00e9valuations","text":"<p>L'\u00e9ch\u00e9ancier et les \u00e9valuations sont disponibles dans la section \u00c9ch\u00e9ancier et \u00c9valuations sommatives.</p>"},{"location":"#organisation-du-site","title":"Organisation du site","text":"<p>Le site est structur\u00e9 par semaines. Chaque semaine, une nouvelle section sera ajout\u00e9e, contenant la th\u00e9orie, les exercices et d'autres informations utiles. Les d\u00e9tails sur les \u00e9valuations sommatives sont regroup\u00e9s dans la section \u00c9valuations sommatives.</p>"},{"location":"#pour-me-joindre","title":"Pour me joindre","text":"<p>Les \u00e9l\u00e8ves du cours peuvent me contacter via MIO dans Ominvox. Les personnes \u00e0 l'ext\u00e9rieur du Coll\u00e8ge de Maisonneuve peuvent me contacter par courriel.</p>"},{"location":"#code-source-du-site","title":"Code source du site","text":"<p>Le code source du site est disponible ici. N'h\u00e9sitez pas \u00e0 contribuer!</p>"},{"location":"#droits-dauteur","title":"Droits d'auteur","text":"<p>Le contenu de ce site, y compris le code, les textes et autres mat\u00e9riaux, est mis \u00e0 disposition selon la licence suivante: Creative Commons Attribution 4.0 International (CC BY 4.0)</p>"},{"location":"echeancier/","title":"\u00c9ch\u00e9ancier","text":"<p>Avertissement</p> <p>En cas de diff\u00e9rence entre les informations pr\u00e9sent\u00e9es ci-dessous et celles du plan de cours, les informations du plan de cours pr\u00e9valent.</p> Semaine Th\u00e8me Objectifs Contenu Activit\u00e9s p\u00e9dagogiques Semaine 1 Formats d'\u00e9change de donn\u00e9es Comprendre les diff\u00e9rents formats d'\u00e9change de donn\u00e9es <ul><li>Binaire versus texte</li><li>CSV, JSON, XML, YAML, XLSX</li><li>Les diff\u00e9rences, avantages, inconv\u00e9nients, etc.</li></ul> Analyse de code, Lectures et recherche sur l'histoire des formats Semaine 2 T\u00e2ches asynchrones Comprendre le m\u00e9canisme d\u2019ex\u00e9cution de code asynchrone <ul><li>Promesses, mot-cl\u00e9s async et await</li></ul> Exercice avec production de code Semaine 3 La modularisation en Javascript Comprendre les m\u00e9canismes d\u2019inclusion de code et de production de modules exportables en JavaScript <ul><li>Port\u00e9e et espace de noms</li><li>Notion : Stateless vs Statefull</li><li>Exporter et importer une classe</li></ul> Exercice avec production de code, Exercice 1 (10%) Semaine 4 Formats d'\u00e9change de donn\u00e9es 2 Mettre en pratique l\u2019envoi de donn\u00e9es CSV et JSON <ul><li>Node vs Express</li><li>Ex\u00e9cution d\u2019une application Express</li><li>Installation : Sqlite3, Knex</li></ul> Labo sur l\u2019envoi d\u2019un fichier CSV, Labo sur l\u2019envoi d\u2019une r\u00e9ponse HTTP dont le corps est en JSON Semaine 5 Micros-services et protocoles Comprendre ce qu\u2019est un micro-service versus une application monolithique <ul><li>Diff\u00e9rence entre protocoles SOAP et REST</li><li>Architecture des Micro-services</li></ul> Recherche et lectures Semaine 6 Authentification Comprendre le m\u00e9canisme d\u2019authentification et l\u2019impl\u00e9menter <ul><li>Cr\u00e9ation de Token</li><li>G\u00e9n\u00e9ration d\u2019un token \u00e0 l\u2019aide de jsonwebtoken</li><li>Installation de bcryptjs</li></ul> Production de code source, Exercice 2 (15%) Semaine 7 Examen de mi-session Examen de mi-session (20%) Semaine 8 API Rest 1 Comment tester une API? <ul><li>D\u00e9velopper les routes de lecture (R du CRUD)</li><li>Installation : Postman</li></ul> Production de code source Semaine 9 API Rest 2 Validation des donn\u00e9es dans une API <ul><li>Installation : express validator</li></ul> Production de code source Semaine 10 API Rest 3 Transactions (ajout / modification / suppression) simples Production de code source, Exercice 3 (10%) Semaine 11 API Rest 4 Transactions (ajout / modification) complexes Production de code source Semaine 12 API Rest 5 Documenter l\u2019API Production de code source, Exercice 4 (15%) Semaine 13 Envoi de fichiers Recevoir des donn\u00e9es binaires par le protocole HTTP <ul><li>Mise \u00e0 jour de donn\u00e9es en lot avec la r\u00e9ception d\u2019un fichier CSV</li></ul> Production de code source Semaine 14 R\u00e9vision Retour sur la mati\u00e8re du cours en vue de l\u2019\u00e9preuve finale R\u00e9vision Semaine 15 \u00c9preuve finale \u00c9preuve finale (30%)"},{"location":"evaluations/","title":"\u00c9valuations sommatives","text":"<p>Avertissement</p> <p>En cas de diff\u00e9rence entre les informations pr\u00e9sent\u00e9es ci-dessous et celles du plan de cours, les informations du plan de cours pr\u00e9valent.</p> \u00c9valuation Individuel / \u00e9quipe Pond\u00e9ration Distribution de l'\u00e9nonc\u00e9 Remise du travail R\u00e9troaction du professeur Exercice 1 Individuel 10% Semaine 3 Semaine 4 Semaine 5 Exercice 2 Individuel 15% Semaine 5 Semaine 6 Semaine 7 Examen de mi-session Individuel 20% Semaine 7 Semaine 7 Semaine 8 Exercice 3 Individuel 10% Semaine 10 Semaine 11 Semaine 12 Exercice 4 Individuel 15% Semaine 12 Semaine 13 Semaine 14 \u00c9preuve finale Individuel 30% Semaine 15 Semaine 15"},{"location":"semaine_01/","title":"Semaine 1","text":""},{"location":"semaine_01/#au-programme","title":"Au programme","text":"<ul> <li>Pr\u00e9sentation du professeur</li> <li>Pr\u00e9sentation du cours</li> <li>Participation optionnelle sur GitHub</li> <li>Questionnaire pour mieux vous conna\u00eetre sur Moodle</li> <li>Qu'est-ce qu'une donn\u00e9e?</li> <li>Avant et apr\u00e8s l'av\u00e8nement d'Internet</li> <li>Les diff\u00e9rents formats d'\u00e9change de donn\u00e9es</li> <li>Exercices formatifs</li> </ul>"},{"location":"semaine_01/exercices/","title":"Exercices formatifs semaine 1","text":"<ul> <li>Avantages et inconv\u00e9nients des formats binaires et textes</li> <li>Formats de donn\u00e9es</li> <li>Internet vs Livraison express</li> <li>Formats de donn\u00e9es et JS</li> <li>CSV de test</li> </ul>"},{"location":"semaine_01/exercices/binaire_texte/","title":"Avantages et inconvenients des format binaires et textes","text":"<p>En \u00e9quipe de 4 \u00e0 5 personnes, discutez des avantages et inconv\u00e9nients des formats binaires et textes.</p>"},{"location":"semaine_01/exercices/format_donnees/","title":"Formats de donn\u00e9es","text":"<p>En \u00e9quipe de 4 \u00e0 5 personnes, trouvez les principales caract\u00e9ristiques des formats de donn\u00e9es suivants : - CSV - XLSX - XML - SGML - YAML - JSON</p>"},{"location":"semaine_01/exercices/internet_vs_livraison/","title":"Internet vs Livraison express","text":"<p>Vous travaillez pour un studio de cin\u00e9ma. Votre patron vous charge de transmettre pour 4 t\u00e9raoctets de donn\u00e9es de film \u00e0 un client. Vous avez le choix entre deux moyens de transmission :</p> <ol> <li>Par Internet, avec une connexion de 100 Mbps (M\u00e9ga bits par seconde).</li> <li>Par la poste, avec un service de livraison express.<ol> <li>Le vitesse d'\u00e9crire sur un disque dur est de 150 Mo/s (M\u00e9ga octets par seconde).</li> <li>Le service de livraison express prend 4 heures pour la livraison.</li> </ol> </li> </ol>"},{"location":"semaine_01/exercices/internet_vs_livraison/#question","title":"Question","text":"<ul> <li>Quel est le moyen le plus rapide pour transmettre les donn\u00e9es?</li> </ul>"},{"location":"semaine_01/theorie/avant_apres_internet/","title":"Comment transmettre des donn\u00e9es","text":""},{"location":"semaine_01/theorie/avant_apres_internet/#introduction","title":"Introduction","text":"<p>Avant l\u2019apparition et la g\u00e9n\u00e9ralisation d\u2019Internet, le transfert et le stockage de donn\u00e9es reposaient essentiellement sur des supports physiques (disquettes, CD-ROM, bandes magn\u00e9tiques, etc.). Aujourd\u2019hui, la majorit\u00e9 des \u00e9changes passent par des protocoles de communication en r\u00e9seau (HTTP, FTP, etc.) et des formats num\u00e9riques vari\u00e9s.</p>"},{"location":"semaine_01/theorie/avant_apres_internet/#avant-lavenement-dinternet","title":"Avant l\u2019av\u00e8nement d\u2019Internet","text":""},{"location":"semaine_01/theorie/avant_apres_internet/#supports-de-stockage-principaux","title":"Supports de stockage principaux","text":"<ol> <li> <p>Disquettes (Floppy disks)  </p> <ul> <li>Capacit\u00e9 : entre 360 Ko et 1,44 Mo.  </li> <li>Usage : transfert de petits fichiers ou utilisation de plusieurs disquettes pour des fichiers plus volumineux.  </li> <li>Limites : fiabilit\u00e9 perfectible, faible capacit\u00e9, usure physique.</li> </ul> </li> <li> <p>Bandes magn\u00e9tiques </p> <ul> <li>Utilis\u00e9es principalement pour les sauvegardes de grande envergure dans les entreprises.  </li> </ul> </li> <li> <p>Cassettes audio </p> <ul> <li>Utilis\u00e9es pour le stockage de donn\u00e9es sur les premiers ordinateurs personnels.</li> <li>Capacit\u00e9 limit\u00e9e, fiabilit\u00e9 discutable.</li> </ul> </li> <li> <p>CD-ROM </p> <ul> <li>\u00c0 partir des ann\u00e9es 90</li> <li>Capacit\u00e9 allant de 650 Mo \u00e0 700 Mo.  </li> <li>Support optique plus fiable que la disquette, mais toujours un support physique.  </li> <li>Principal moyen de distribution de logiciels et de jeux vers la fin des ann\u00e9es 90.</li> </ul> </li> <li> <p>Disques durs </p> <ul> <li>Apparus dans les ann\u00e9es 1950, mais ont pris de l\u2019importance dans les ann\u00e9es 80 et 90.</li> <li>Capacit\u00e9 de stockage plus importante, mais toujours un support physique.</li> <li>Toujours utilis\u00e9s pour le stockage de nos jours.</li> </ul> </li> </ol>"},{"location":"semaine_01/theorie/avant_apres_internet/#mode-de-diffusion-et-partage","title":"Mode de diffusion et partage","text":"<ul> <li>\u00c9changes physiques : Partage des disquettes, bandes, disques durs ou CD en main propre.  </li> <li>Contraintes :  <ul> <li>Temps.  </li> <li>Limitation de capacit\u00e9.</li> <li>Risque de d\u00e9gradation du support.</li> </ul> </li> </ul>"},{"location":"semaine_01/theorie/avant_apres_internet/#apres-lavenement-dinternet","title":"Apr\u00e8s l\u2019av\u00e8nement d\u2019Internet","text":"<p>Avec Internet, la plupart des \u00e9changes de donn\u00e9es se font via des protocoles de communication permettant le transfert d\u2019informations entre des machines distantes, sans support physique direct. Parmis les plus connus on retrouve :</p> <ul> <li> <p>HTTP (HyperText Transfer Protocol) :  </p> <ul> <li>Permet la communication entre un client (navigateur web, par exemple) et un serveur.  </li> <li>Fonctionne par requ\u00eates (GET, POST, PUT, etc.) et r\u00e9ponses, qui contiennent toutes un en-t\u00eate (header) et un contenu (body).  </li> <li>Le body (ou corps) peut contenir des donn\u00e9es brutes au format texte ou binaire (HTML, JSON, CSV, Excel, YAML, etc.).  </li> <li>Le protocole a \u00e9volu\u00e9 au fil du temps : HTTP/1.0, HTTP/1.1, HTTP/2, et plus r\u00e9cemment HTTP/3.</li> </ul> </li> <li> <p>FTP (File Transfer Protocol) :</p> <ul> <li>Protocole d\u00e9di\u00e9 au transfert de fichiers entre un client et un serveur.</li> <li>Moins utilis\u00e9 que HTTP pour les \u00e9changes de donn\u00e9es en ligne.</li> </ul> </li> <li> <p>SMTP/IMAP/POP :</p> <ul> <li>Protocoles pour l\u2019envoi de courriels.</li> <li>Permet de transf\u00e9rer des messages entre serveurs de messagerie.</li> </ul> </li> </ul>"},{"location":"semaine_01/theorie/avant_apres_internet/#evolution-avantages-et-inconvenients","title":"\u00c9volution, avantages et inconv\u00e9nients","text":""},{"location":"semaine_01/theorie/avant_apres_internet/#avantages-de-lere-internet","title":"Avantages de l\u2019\u00e8re Internet","text":"<ul> <li>D\u00e9mat\u00e9rialisation : La plupart des individus et des entreprises stockent et partagent leur donn\u00e9es     sans avoir \u00e0 se soucier de supports physiques.</li> <li>Accessibilit\u00e9 \u00e0 grande \u00e9chelle : Possible d'envoyer et de recevoir des donn\u00e9es depuis n\u2019importe o\u00f9.  </li> <li>Collaboration facilit\u00e9e : Utilisation de services en ligne, transfert instantan\u00e9 de fichiers.</li> </ul>"},{"location":"semaine_01/theorie/avant_apres_internet/#limites-et-defis","title":"Limites et d\u00e9fis","text":"<ul> <li>D\u00e9pendance au r\u00e9seau : Sans connexion Internet, impossible d\u2019acc\u00e9der \u00e0 ses donn\u00e9es. </li> <li>S\u00e9curit\u00e9 : Risques de piratage, vol de donn\u00e9es, etc.  </li> <li>Confidentialit\u00e9 : Encryption n\u00e9cessaire pour prot\u00e9ger les donn\u00e9es sensibles.  </li> <li>Obsolescence rapide : Les standards et technologies \u00e9voluent vite rapidement.</li> <li>Vie priv\u00e9e : Risque de surveillance et de collecte de donn\u00e9es   personnelles. Il faut cr\u00e9er un compte pour son thermostat et bient\u00f4t pourquoi   pas sa brosse \u00e0 dents.</li> </ul>"},{"location":"semaine_01/theorie/definition_donnee/","title":"Qu'est-ce qu'une donn\u00e9e ?","text":"<p>Le titre du cours est \"services d'\u00e9change de donn\u00e9es\". Mais qu'est-ce qu'une donn\u00e9e? En informatique, on pourrait tenter de la d\u00e9finir comme une suite de 0 et de 1. Lorsque la suite de 0 et de 1 est entrepos\u00e9es sur un support physique, on appelle en g\u00e9n\u00e9ral une telle suite un fichier. Mais il faut bien comprendre que cette suite n'a aucun sens en soi. Si on vous remet un fichier qui contient la suite de 0 et de 1 suivante : <pre><code>01001000 01100101 01101100 01101100 01101111 00101100 00100000 01110111 01101111 01110010 01101100 01100100\n</code></pre> que faites-vous avec? Vous ne pouvez rien en faire, car vous ne savez pas comment interpr\u00e9ter ces octets (s\u00e9quence de huit bits). Il faut une convention, un format, pour d\u00e9crire comment interpr\u00e9ter cette s\u00e9quence d'octets. Par exemple, si on vous dit que c'est un fichier texte UTF-8, vous pourrez lire <code>Hello, world</code>.</p> <p>De fa\u00e7on g\u00e9n\u00e9rale, le format du fichier est indiqu\u00e9 par son extension. Par exemple, un fichier <code>.docx</code> est un fichier Word, un fichier <code>.pdf</code> est un fichier PDF dont le nom est l'acronyme de Portable Document Format, etc.</p>"},{"location":"semaine_01/theorie/definition_donnee/#formats-binaires-et-formats-textes","title":"Formats binaires et formats textes","text":"<p>Il existe deux grandes familles de formats de donn\u00e9es : les formats binaires et les formats textes. Les formats binaires sont des s\u00e9quences d'octets qui ne sont pas directement lisibles par un humain. Par exemple, un fichier <code>.docx</code> est un fichier binaire, alors qu'un fichier <code>.txt</code> est un fichier texte.</p> <p>L'encodage d'un fichier binaire est souvent sp\u00e9cifique \u00e0 une application. En revanche, les fichiers textes sont souvent encod\u00e9s selon des standards reconnus. Par exemple, de nos jours les fichiers textes sont souvent encod\u00e9s en UTF-8, qui est un standard de l'Unicode Consortium.</p>"},{"location":"semaine_01/theorie/definition_donnee/#avantages-et-inconvenients-des-formats-binaires-et-textes","title":"Avantages et inconv\u00e9nients des formats binaires et textes","text":"<p>Exercice : En \u00e9quipe de 4 \u00e0 5 personnes, discutez des avantages et inconv\u00e9nients des formats binaires et textes.</p>"},{"location":"semaine_01/theorie/format_donnees/","title":"Formats de donn\u00e9es","text":"<p>Exercice</p>"},{"location":"semaine_02/","title":"Semaine 2","text":""},{"location":"semaine_02/#au-programme","title":"Au programme","text":"<ul> <li>Javascript, les bases</li> <li>Fonctions</li> <li>Objets et tableaux</li> <li>JavaScript asynchrone</li> <li>Exercices formatifs</li> </ul>"},{"location":"semaine_02/exercices/","title":"Exercices formatifs semaine 2","text":"<ul> <li>R\u00e9visions</li> <li>Code asynchrone</li> </ul>"},{"location":"semaine_02/theorie/asynchrone/","title":"JavaScript asynchrone dans Node.js","text":"<p>JavaScript \u00e9tant \u00e0 la base un langage monothread, Node.js utilise la boucle d\u2019\u00e9v\u00e9nements (event loop), mise en \u0153uvre par la librairie libuv, pour g\u00e9rer l\u2019ex\u00e9cution du code asynchrone.  </p> <p>Tout comme dans un navigateur, on a toujours le concept de pile d\u2019ex\u00e9cution, de file d\u2019attente, et d\u2019un Event Loop qui orchestre l\u2019ex\u00e9cution. Toutefois, les APIs asynchrones disponibles sont sp\u00e9cifiques \u00e0 Node.js (acc\u00e8s disque, r\u00e9seau, etc.), plut\u00f4t qu\u2019aux Web APIs (comme <code>fetch</code> dans un navigateur).</p>"},{"location":"semaine_02/theorie/asynchrone/#le-modele-asynchrone-en-nodejs","title":"Le mod\u00e8le asynchrone en Node.js","text":""},{"location":"semaine_02/theorie/asynchrone/#le-role-de-libuv","title":"Le r\u00f4le de libuv","text":"<ul> <li>libuv est une biblioth\u00e8que C utilis\u00e9e par Node.js pour la gestion multi-plateforme des I/O asynchrones.  </li> <li>Elle g\u00e8re la boucle d\u2019\u00e9v\u00e9nements, les threads en arri\u00e8re-plan (Thread Pool) pour des t\u00e2ches comme l\u2019acc\u00e8s au syst\u00e8me de fichiers, le chiffrement, DNS, etc.</li> </ul>"},{"location":"semaine_02/theorie/asynchrone/#les-apis-asynchrones-de-nodejs","title":"Les APIs asynchrones de Node.js","text":"<p>Contrairement \u00e0 un navigateur, Node.js n\u2019a pas de DOM. En revanche, Node.js propose des modules asynchrones pour :</p> <ul> <li>fs (File System) : lecture/\u00e9criture de fichiers.</li> <li>http : cr\u00e9ation de serveurs HTTP, requ\u00eates sortantes, etc.</li> <li>net : sockets bas niveau pour des connexions r\u00e9seau.</li> <li>crypto : op\u00e9rations cryptographiques.</li> <li>etc.</li> </ul> <p>Toutes ces APIs suivent des patrons asynchrones (avec callbacks, Promises, <code>async/await</code>).</p>"},{"location":"semaine_02/theorie/asynchrone/#callbacks-et-callback-hell-dans-nodejs","title":"Callbacks et \u00ab callback hell \u00bb dans Node.js","text":""},{"location":"semaine_02/theorie/asynchrone/#exemple-avec-le-module-fs","title":"Exemple avec le module <code>fs</code>","text":"<p>Historiquement, la majorit\u00e9 des fonctions Node.js utilisaient des callbacks suivant la convention d\u2019erreur en premier (error-first callback) :</p> <pre><code>const fs = require('fs');\n\nfs.readFile('monFichier.txt', 'utf8', (err, data) =&gt; {\n  if (err) {\n    return console.error(\"Erreur de lecture :\", err);\n  }\n  console.log(\"Contenu du fichier :\", data);\n});\n</code></pre> <p>Le premier argument de la fonction de rappel repr\u00e9sente une \u00e9ventuelle erreur et le deuxi\u00e8me argument repr\u00e9sente le r\u00e9sultat de l\u2019op\u00e9ration asynchrone.</p>"},{"location":"semaine_02/theorie/asynchrone/#lenchassement-de-callbacks","title":"L'ench\u00e2ssement de callbacks","text":"<p>Lorsqu\u2019on a plusieurs op\u00e9rations asynchrones \u00e0 effectuer en s\u00e9quence, on peut tomber dans le pi\u00e8ge du \u00ab callback hell \u00bb :</p> <p>Le code suivant lit trois fichiers en s\u00e9quence et affiche leur contenu : <pre><code>fs.readFile('fichier1.txt', 'utf8', (err, data1) =&gt; {\n  if (err) {\n    return console.error(\"Erreur de lecture :\", err);\n  }\n  fs.readFile('fichier2.txt', 'utf8', (err, data2) =&gt; {\n    if (err) {\n      return console.error(\"Erreur de lecture :\", err);\n    }\n    fs.readFile('fichier3.txt', 'utf8', (err, data3) =&gt; {\n      if (err) {\n        return console.error(\"Erreur de lecture :\", err);\n      }\n      console.log(\"Contenu des fichiers :\", data1, data2, data3);\n    });\n  });\n});\n</code></pre></p> <p>La logique de l\u2019application devient difficile \u00e0 suivre et \u00e0 maintenir.</p>"},{"location":"semaine_02/theorie/asynchrone/#promesses-promises-en-nodejs","title":"Promesses (Promises) en Node.js","text":"<p>Pour rendre le code asynchrone plus lisible, Node.js a progressivement adopt\u00e9 les Promises. Une promesse est un objet qui repr\u00e9sente le r\u00e9sultat \u00e9ventuel (r\u00e9ussi ou \u00e9chou\u00e9) d\u2019une op\u00e9ration asynchrone. En d\u2019autres termes, c\u2019est comme un contrat qui dit\u202f: \u201cJe vais faire quelque chose qui prend du temps et, quand j\u2019aurai fini, je te donnerai soit un succ\u00e8s (resolve), soit une erreur (reject).\u201d</p> <p>Voici les points cl\u00e9s \u00e0 retenir :</p> <ul> <li>Asynchrone : une promesse g\u00e8re du code qui s\u2019ex\u00e9cute en arri\u00e8re-plan, sans bloquer le reste du programme. </li> <li>Trois \u00e9tats : <ul> <li>en attente (pending) : l\u2019op\u00e9ration est en cours</li> <li>r\u00e9ussie (fulfilled) : l\u2019op\u00e9ration s\u2019est termin\u00e9e avec succ\u00e8s</li> <li>\u00e9chou\u00e9e (rejected) : l\u2019op\u00e9ration a rencontr\u00e9 une erreur. </li> </ul> </li> <li>M\u00e9thodes then() et catch() : then() est appel\u00e9e quand la promesse est r\u00e9ussie et re\u00e7oit la valeur de retour, catch() est appel\u00e9e quand la promesse a \u00e9chou\u00e9 et re\u00e7oit l\u2019erreur.</li> </ul>"},{"location":"semaine_02/theorie/asynchrone/#construction-dune-promesse","title":"Construction d\u2019une promesse","text":"<p>Pour cr\u00e9er une promesse, on utilise le constructeur <code>Promise</code> qui prend une fonction de rappel avec deux arguments : <code>resolve</code> et <code>reject</code>. Voici un exemple qui simule une op\u00e9ration asynchrone de lecture de fichier :</p> <pre><code>const fs = require('fs');\n\nfunction lireFichier(nomFichier) {\n  return new Promise((resolve, reject) =&gt; {\n    fs.readFile(nomFichier, 'utf8', (err, data) =&gt; {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(data);\n      }\n    });\n  });\n}\n\nlireFichier('monFichier.txt')\n  .then(data =&gt; console.log(\"Contenu du fichier :\", data))\n  .catch(err =&gt; console.error(\"Erreur de lecture :\", err));\n</code></pre> <p>Si vous voulez retourner une valeur directement, vous pouvez utiliser <code>Promise.resolve(valeur)</code> ou <code>Promise.reject(erreur)</code>. Par exemple :</p> <pre><code>function getNombreAleatoire() {\n  return Promise.resolve(Math.random());\n}\n\ngetNombreAleatoire().then(nombre =&gt; console.log(\"Nombre al\u00e9atoire :\", nombre));\n</code></pre>"},{"location":"semaine_02/theorie/asynchrone/#chainage-de-promesses","title":"Cha\u00eenage de promesses","text":"<p>Voici un exemple classique o\u00f9 on encha\u00eene plusieurs op\u00e9rations asynchrones. D\u2019abord, on va illustrer la version callback hell, puis la version avec Promises (qui rend le code plus lin\u00e9aire et lisible).</p> <p>Imaginons qu\u2019on ait trois fonctions asynchrones (par exemple, r\u00e9cup\u00e9rer un utilisateur, puis ses articles, puis les commentaires d\u2019un de ses articles) qui s\u2019utilisent avec des callbacks\u202f:</p> <pre><code>function getUser(userId, callback) {\n  setTimeout(() =&gt; {\n    console.log(\"getUser termin\u00e9\");\n    // On simule la r\u00e9cup\u00e9ration d\u2019un utilisateur\n    callback(null, { id: userId, name: \"Alice\" });\n  }, 500);\n}\n\nfunction getPosts(userId, callback) {\n  setTimeout(() =&gt; {\n    console.log(\"getPosts termin\u00e9\");\n    // On simule la r\u00e9cup\u00e9ration de posts li\u00e9s \u00e0 l\u2019utilisateur\n    callback(null, [{ postId: 101, title: \"Mon premier article\" }]);\n  }, 500);\n}\n\nfunction getComments(postId, callback) {\n  setTimeout(() =&gt; {\n    console.log(\"getComments termin\u00e9\");\n    // On simule la r\u00e9cup\u00e9ration de commentaires pour un article\n    callback(null, [\"Super !\", \"Merci pour l'article\"]);\n  }, 500);\n}\n</code></pre> <p>Pour encha\u00eener ces trois op\u00e9rations (r\u00e9cup\u00e9rer l\u2019utilisateur, puis ses articles, puis les commentaires du premier article), on peut faire : <pre><code>getUser(1, function (err, user) {\n  if (err) {\n    console.error(err);\n    return;\n  }\n  getPosts(user.id, function (err, posts) {\n    if (err) {\n      console.error(err);\n      return;\n    }\n    getComments(posts[0].postId, function (err, comments) {\n      if (err) {\n        console.error(err);\n        return;\n      }\n      console.log(\"Commentaires r\u00e9cup\u00e9r\u00e9s :\", comments);\n    });\n  });\n});\n</code></pre></p> <p>Maintenant, les m\u00eames fonctions, mais en retournant des Promesses au lieu d\u2019utiliser des callbacks : <pre><code>function getUser(userId) {\n  return new Promise((resolve, reject) =&gt; {\n    setTimeout(() =&gt; {\n      console.log(\"getUser termin\u00e9\");\n      // Simulation de la r\u00e9cup\u00e9ration d\u2019un utilisateur\n      const user = { id: userId, name: \"Alice\" };\n      resolve(user); // on appelle resolve quand tout va bien\n    }, 500);\n  });\n}\n\nfunction getPosts(userId) {\n  return new Promise((resolve, reject) =&gt; {\n    setTimeout(() =&gt; {\n      console.log(\"getPosts termin\u00e9\");\n      // Simulation de la r\u00e9cup\u00e9ration de posts\n      const posts = [{ postId: 101, title: \"Mon premier article\" }];\n      resolve(posts);\n    }, 500);\n  });\n}\n\nfunction getComments(postId) {\n  return new Promise((resolve, reject) =&gt; {\n    setTimeout(() =&gt; {\n      console.log(\"getComments termin\u00e9\");\n      // Simulation de la r\u00e9cup\u00e9ration de commentaires\n      const comments = [\"Super !\", \"Merci pour l'article\"];\n      resolve(comments);\n    }, 500);\n  });\n}\n</code></pre></p> <p>Pour encha\u00eener les op\u00e9rations, on peut cha\u00eener les appels gr\u00e2ce aux m\u00e9thodes <code>then()</code> et <code>catch()</code> :</p> <pre><code>getUser(1)\n  .then((user) =&gt; {\n    return getPosts(user.id);\n  })\n  .then((posts) =&gt; {\n    return getComments(posts[0].postId);\n  })\n  .then((comments) =&gt; {\n    console.log(\"Commentaires r\u00e9cup\u00e9r\u00e9s :\", comments);\n  })\n  .catch((err) =&gt; {\n    console.error(err);\n  });\n</code></pre>"},{"location":"semaine_02/theorie/asynchrone/#promiseall","title":"<code>Promise.all()</code>","text":"<p>Si vous avez plusieurs promesses \u00e0 ex\u00e9cuter en parall\u00e8le, vous pouvez utiliser <code>Promise.all([...])</code> qui prend un tableau de promesses et renvoie une nouvelle promesse qui est r\u00e9solue quand toutes les promesses du tableau sont r\u00e9solues.</p> <pre><code>Promise.all([getUser(1), getPosts(1), getComments(101)])\n  .then(([user, posts, comments]) =&gt; {\n    console.log(\"Utilisateur :\", user);\n    console.log(\"Articles :\", posts);\n    console.log(\"Commentaires :\", comments);\n  })\n  .catch((err) =&gt; {\n    console.error(err);\n  });\n</code></pre> <p>Par contre, si une seule des promesses est rejet\u00e9e, la promesse retourn\u00e9e par <code>Promise.all()</code> sera rejet\u00e9e. Aussi l'ordre d'ex\u00e9cution des promesses n'est pas garanti.</p>"},{"location":"semaine_02/theorie/asynchrone/#une-promesse-sans-then-ni-catch","title":"Une promesse sans <code>then</code> ni <code>catch</code>","text":"<p>Si vous n'appelez ni <code>then</code> ni <code>catch</code> sur une promesse, elle sera ex\u00e9cut\u00e9e quand m\u00eame. S'il y a une erreur, elle sera rejet\u00e9e sans \u00eatre g\u00e9r\u00e9e, ce qui peut provoquer des erreurs non g\u00e9r\u00e9es (unhandled rejections). Si la promesse r\u00e9ussit mais qu'on ne fait rien avec le r\u00e9sultat, cela ne plante pas, mais c\u2019est inutile.</p>"},{"location":"semaine_02/theorie/asynchrone/#catch-est-un-then-special","title":"<code>catch</code> est un <code>then</code> sp\u00e9cial","text":"<p><code>catch</code> est en fait un raccourci pour <code>then(undefined, onRejected)</code>. Cela signifie que <code>catch</code> peut \u00eatre utilis\u00e9 pour g\u00e9rer les erreurs de n\u2019importe quelle promesse dans la cha\u00eene de promesses.</p>"},{"location":"semaine_02/theorie/asynchrone/#finally","title":"<code>finally</code>","text":"<p><code>finally</code> est une m\u00e9thode qui est appel\u00e9e \u00e0 la fin de la cha\u00eene de promesses, qu\u2019elles soient r\u00e9solues ou rejet\u00e9es. Elle est utile pour effectuer des op\u00e9rations de nettoyage ou de finalisation, par exemple pour fermer une connexion r\u00e9seau ou un fichier.</p> <pre><code>getUser(1)\n  .then((user) =&gt; {\n    console.log(\"Utilisateur :\", user);\n  })\n  .catch((err) =&gt; {\n    console.error(err);\n  })\n  .finally(() =&gt; {\n    console.log(\"Op\u00e9ration termin\u00e9e\");\n  });\n</code></pre>"},{"location":"semaine_02/theorie/asynchrone/#avantages-des-promesses","title":"Avantages des Promesses","text":"<ul> <li>Lisibilit\u00e9 : plus besoin d\u2019imbriquer des fonctions callback dans d\u2019autres callbacks.</li> <li>Gestion centralis\u00e9e des erreurs : on peut catcher les erreurs \u00e0 la fin avec un simple .catch(...).</li> <li>Cha\u00eenage plus clair : chaque then re\u00e7oit le r\u00e9sultat du pr\u00e9c\u00e9dent et peut   renvoyer une nouvelle promesse ou une valeur.</li> </ul>"},{"location":"semaine_02/theorie/asynchrone/#references","title":"R\u00e9f\u00e9rences","text":"<ul> <li>Promises - MDN</li> </ul>"},{"location":"semaine_02/theorie/asynchrone/#asyncawait","title":"Async/Await","text":"<p>Les Promises sont une am\u00e9lioration par rapport aux callbacks, mais elles peuvent devenir verbeuses lorsqu\u2019on encha\u00eene plusieurs op\u00e9rations asynchrones. Pour rendre le code encore plus lisible, JavaScript propose les mots-cl\u00e9s <code>async</code> et <code>await</code>.</p> <ul> <li><code>async</code> : d\u00e9clare une fonction asynchrone qui retourne une Promesse.</li> <li><code>await</code> : attend la r\u00e9solution d\u2019une Promesse. Il ne peut \u00eatre utilis\u00e9 que   dans une fonction d\u00e9clar\u00e9e avec <code>async</code>.</li> </ul> <p>Voici comment on pourrait r\u00e9\u00e9crire l\u2019exemple pr\u00e9c\u00e9dent avec <code>async</code> et <code>await</code> :</p> <pre><code>async function main() {\n  try {\n    const user = await getUser(1);\n    const posts = await getPosts(user.id);\n    const comments = await getComments(posts[0].postId);\n    console.log(\"Commentaires r\u00e9cup\u00e9r\u00e9s :\", comments);\n  } catch (err) {\n    console.error(err);\n  }\n}\n\nmain();\n</code></pre> <p>L'order dans lequel les op\u00e9rations sont effectu\u00e9es est plus clair, et on peut g\u00e9rer les erreurs avec un simple bloc <code>try/catch</code>. Notez que chaque <code>await</code>  ne s'ex\u00e9cute qu'apr\u00e8s que l'instruction <code>await</code> pr\u00e9c\u00e9dente ait \u00e9t\u00e9 r\u00e9solue.</p>"},{"location":"semaine_02/theorie/asynchrone/#gestion-des-erreurs","title":"Gestion des erreurs","text":"<p>Dans une fonction <code>async</code>, les erreurs peuvent \u00eatre g\u00e9r\u00e9es avec un bloc <code>try/catch</code>. C'est l'\u00e9quivalent de la m\u00e9thode <code>catch()</code> d'une Promesse. Si une fonction <code>async</code> l\u00e8ve une erreur qui n'est pas g\u00e9r\u00e9e, la promesse d\u00e9finie par la fonction sera rejet\u00e9e et l'erreur sera propag\u00e9e.</p>"},{"location":"semaine_02/theorie/asynchrone/#recommandations-et-bonnes-pratiques","title":"Recommandations et bonnes pratiques","text":"<ul> <li>Toujours g\u00e9rer les erreurs : entourez votre code await d\u2019un try/catch, ou retournez des promesses correctement rejet\u00e9es afin de ne pas avoir de rejets non g\u00e9r\u00e9s (unhandled rejections).</li> <li>\u00c9viter les boucles <code>for</code> qui font trop d\u2019op\u00e9rations <code>await</code> en s\u00e9rie si vous voulez du parall\u00e9lisme. Il peut \u00eatre pr\u00e9f\u00e9rable de lancer plusieurs promesses simultan\u00e9ment et de faire un <code>await Promise.all([...])</code> si vous n\u2019avez pas besoin de l\u2019ordre d\u2019ex\u00e9cution.</li> </ul>"},{"location":"semaine_02/theorie/fonctions/","title":"Fonctions","text":"<p>Les fonctions en JavaScript sont des objets de premi\u00e8re classe, ce qui signifie qu'elles peuvent \u00eatre assign\u00e9es \u00e0 des variables, pass\u00e9es en param\u00e8tre et retourn\u00e9es par d'autres fonctions. Voici comment d\u00e9clarer une fonction en JavaScript :</p> <pre><code>function add(a, b) {\n  return a + b;\n}\n\nlet result = add(1, 2);\nconsole.log(result); // 3\n</code></pre> <p>Il est \u00e9galement possible de d\u00e9clarer une fonction et de l'assigner \u00e0 une variable :</p> <pre><code>let multiply = function(a, b) {\n  return a * b;\n};\n\nlet result = multiply(2, 3);\nconsole.log(result); // 6\n</code></pre> <p>Vous pouvez ainsi d\u00e9finir une fonction \u00e0 l'int\u00e9rieur d'une autre fonction :</p> <pre><code>function outerFunction() {\n  function innerFunction() {\n    console.log('Hello from inner function!');\n  }\n\n  innerFunction();\n}\n\nouterFunction(); // Affiche 'Hello from inner function!'\n</code></pre>"},{"location":"semaine_02/theorie/fonctions/#parametres-de-fonction","title":"Param\u00e8tres de fonction","text":"<p>Les fonctions en JavaScript peuvent prendre un nombre variable de param\u00e8tres. Si vous appelez une fonction avec moins de param\u00e8tres que pr\u00e9vu, les param\u00e8tres manquants seront <code>undefined</code>. Si vous appelez une fonction avec plus de param\u00e8tres que pr\u00e9vu, les param\u00e8tres suppl\u00e9mentaires seront ignor\u00e9s.</p> <pre><code>function add(a, b) {\n  return a + b;\n}\n\nconsole.log(add(1)); // NaN\nconsole.log(add(1, 2)); // 3\nconsole.log(add(1, 2, 3)); // 3\n</code></pre> <p>Il est possible de d\u00e9finir des valeurs par d\u00e9faut pour les param\u00e8tres d'une fonction :</p> <pre><code>function greet(name = 'World') {\n  console.log(`Hello, ${name}!`);\n}\n\ngreet(); // Affiche 'Hello, World!'\ngreet('Alice'); // Affiche 'Hello, Alice!'\n</code></pre> <p>Lorsqu'un objet est pass\u00e9 en param\u00e8tre \u00e0 une fonction, il est pass\u00e9 par r\u00e9f\u00e9rence, ce qui signifie que si vous modifiez l'objet \u00e0 l'int\u00e9rieur de la fonction, les modifications seront visibles \u00e0 l'ext\u00e9rieur de la fonction. Il en va de m\u00eame pour les tableaux.</p> <pre><code>function increment(obj) {\n  obj.value++;\n}\n\nlet counter = { value: 0 };\nincrement(counter);\nconsole.log(counter.value); // 1\n</code></pre> <pre><code>let numbers = [1, 2, 3];\n\nfunction addNumber(array, number) {\n  array.push(number);\n}\n\naddNumber(numbers, 4);\nconsole.log(numbers); // [1, 2, 3, 4]\n</code></pre>"},{"location":"semaine_02/theorie/fonctions/#nombre-variable-de-parametres","title":"Nombre variable de param\u00e8tres","text":"<p>Il est possible de d\u00e9finir une fonction avec un nombre variable de param\u00e8tres en utilisant l'op\u00e9rateur de propagation (<code>spread operator</code>). Voici un exemple :</p> <pre><code>function sum(...numbers) {\n  return numbers.reduce((acc, val) =&gt; acc + val, 0);\n}\n\nconsole.log(sum(1, 2, 3)); // 6\nconsole.log(sum(1, 2, 3, 4, 5)); // 15\n</code></pre> <pre><code>function greet(...names) {\n  names.forEach(name =&gt; console.log(`Hello, ${name}!`));\n}\n\ngreet('Alice', 'Bob', 'Charlie');\n// Affiche 'Hello, Alice!', 'Hello, Bob!', 'Hello, Charlie!'\n</code></pre> <p>L'op\u00e9rateur de propagation (<code>spread operator</code>) peut \u00eatre utilis\u00e9 apr\u00e8s avoir d\u00e9fini des param\u00e8tres fixes :</p> <pre><code>function greet(greeting, ...names) {\n  names.forEach(name =&gt; console.log(`${greeting}, ${name}!`));\n}\n\ngreet('Hi', 'Alice', 'Bob', 'Charlie');\n// Affiche 'Hi, Alice!', 'Hi, Bob!', 'Hi, Charlie!'\n</code></pre> <p>L'op\u00e9rateur de propagation (<code>spread operator</code>) permet aussi de passer un tableau ou un objet comme une liste d'arguments \u00e0 une fonction. Voici comment l'utiliser :</p> <pre><code>function add(a, b, c) {\n  return a + b + c;\n}\n\nlet numbers = [1, 2, 3];\nlet result = add(...numbers);\nconsole.log(result); // 6\n</code></pre> <pre><code>function greet(firstname, lastname) {\n  console.log(`Hello, ${firstname} ${lastname}!`);\n}\n\nlet person = { firstname: 'Alice', lastname: 'Smith' };\ngreet(...person); // Affiche 'Hello, Alice Smith!'\n</code></pre>"},{"location":"semaine_02/theorie/fonctions/#valeur-de-retour","title":"Valeur de retour","text":"<p>Les fonctions en JavaScript peuvent retourner une valeur \u00e0 l'aide du mot-cl\u00e9 <code>return</code>. Si une fonction ne retourne pas de valeur, elle retourne <code>undefined</code>.</p>"},{"location":"semaine_02/theorie/fonctions/#fonctions-flechees","title":"Fonctions fl\u00e9ch\u00e9es","text":"<p>Les fonctions fl\u00e9ch\u00e9es (<code>arrow functions</code>) sont une syntaxe plus concise pour d\u00e9finir des fonctions en JavaScript. Elles sont souvent utilis\u00e9es pour les fonctions anonymes et les fonctions de rappel (<code>callback functions</code>). Voici comment d\u00e9finir une fonction fl\u00e9ch\u00e9e :</p> <pre><code>let add = (a, b) =&gt; a + b;\n\nlet result = add(1, 2);\nconsole.log(result); // 3\n</code></pre>"},{"location":"semaine_02/theorie/les_bases/","title":"Introduction \u00e0 Javascript","text":""},{"location":"semaine_02/theorie/les_bases/#quest-ce-que-javascript","title":"Qu\u2019est-ce que JavaScript ?","text":""},{"location":"semaine_02/theorie/les_bases/#breve-histoire-et-utilisation","title":"Br\u00e8ve histoire et utilisation","text":"<p>JavaScript a \u00e9t\u00e9 d\u00e9velopp\u00e9 en 1995 par Brendan Eich pour le navigateur Netscape. Aujourd\u2019hui, JavaScript est standardis\u00e9 via l\u2019ECMAScript et conna\u00eet des mises \u00e0 jour r\u00e9guli\u00e8res (ES6/ES2015, ES7, etc.).</p> <p>Les principales utilisations de JavaScript sont :</p> <ul> <li>Interactivit\u00e9 dans les pages web (animations, formulaires, etc.)</li> <li>Applications c\u00f4t\u00e9 serveur avec Node.js</li> <li>Applications mobiles (React Native, Ionic, etc.)</li> <li>D\u00e9veloppement d\u2019applications desktop (Electron)</li> </ul>"},{"location":"semaine_02/theorie/les_bases/#javascript-dans-une-page-web","title":"JavaScript dans une page web","text":"<p>Au d\u00e9part, JavaScript \u00e9tait uniquement utilis\u00e9 dans un navigateur pour ajouter de l'interactivit\u00e9 \u00e0 une page web. Pour une fa\u00e7on simple d'ex\u00e9cuter du JavaScript dans un navigateur, on cr\u00e9e un fichier <code>.html</code> contenant une balise <code>&lt;script&gt;</code>.</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"fr\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\"UTF-8\" /&gt;\n  &lt;title&gt;Mon premier script JavaScript&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1&gt;Bonjour JavaScript !&lt;/h1&gt;\n\n  &lt;script&gt;\n    var x = 1;\n    var y = 2;\n\n    console.log(\"Bonjour depuis le script !\");\n    console.log(x + y);\n    alert(\"Hello World !\");\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Vous pouvez ouvrir le fichier html dans un navigateur pour voir le r\u00e9sultat. Pour mieux voir les messages de la console, ouvrez la console de d\u00e9veloppement de votre navigateur (F12).</p>"},{"location":"semaine_02/theorie/les_bases/#javascript-et-nodejs","title":"JavaScript et node.js","text":"<p>Puisque c'\u00e9tait le seul langage de programmation disponible dans les navigateurs, JavaScript est devenu un langage de programmation tr\u00e8s populaire. De plus, les interpr\u00e9teurs JavaScript des navigateurs sont devenus tr\u00e8s performants. Ainsi, en 2009, Ryan Dahl a cr\u00e9\u00e9 Node.js, une plateforme permettant de faire fonctionner du JavaScript c\u00f4t\u00e9 serveur. Il a adapt\u00e9 le moteur JavaScript V8 de Google Chrome pour qu'il puisse fonctionner en dehors du navigateur.</p> <p>Il est donc maitenant possible d'ex\u00e9cuter du JavaScript en dehors d'un navigateur en utilisant Node.js. Pour ce faire, il suffit d'installer Node.js sur votre machine et de cr\u00e9er un fichier <code>.js</code> contenant votre code JavaScript.</p> <pre><code>// hello.js\nconsole.log(\"Hello World !\");\n</code></pre> <p>Astuce</p> <p>Dans VSCode, l'extension Code Runner permet d'ex\u00e9cuter du code JavaScript directement dans l'\u00e9diteur sans avoir \u00e0 ouvrir un terminal.</p>"},{"location":"semaine_02/theorie/les_bases/#differences-entre-javascript-dans-un-navigateur-et-nodejs","title":"Diff\u00e9rences entre JavaScript dans un navigateur et Node.js","text":"<p>Les objets globaux et les fonctions disponibles dans un navigateur ne sont pas les m\u00eames que ceux disponibles dans Node.js. Par exemple, <code>alert()</code> n'est pas disponible dans Node.js, mais <code>console.log()</code> l'est. De plus, les objets globaux <code>window</code> et <code>document</code> ne sont pas disponibles dans Node.js. En revanche, Node.js offre des objets globaux comme <code>process</code> et <code>global</code>.</p> <p>Donc, bien qu'il s'agisse du m\u00eame langage, il y a des diff\u00e9rences entre JavaScript dans un navigateur et Node.js au niveau des objets globaux et des fonctions disponibles.</p>"},{"location":"semaine_02/theorie/les_bases/#les-bases-de-javascript","title":"Les bases de JavaScript","text":""},{"location":"semaine_02/theorie/les_bases/#variables","title":"Variables","text":"<p>En JavaScript, on d\u00e9clare une variable avec le mot-cl\u00e9 <code>var</code>, <code>let</code> ou <code>const</code>. Il est recommand\u00e9 d'utiliser <code>let</code> ou <code>const</code> plut\u00f4t que <code>var</code> pour d\u00e9clarer des variables.</p> <pre><code>let x = 1;\nconst y = 2;\n</code></pre> <p>La diff\u00e9rence entre <code>let</code> et <code>const</code> est que la valeur d'une variable d\u00e9clar\u00e9e avec <code>const</code> ne peut pas \u00eatre modifi\u00e9e. Par exemple, le code suivant g\u00e9n\u00e8re une erreur :</p> <pre><code>const z = 3;\nz = 4; // Erreur : impossible de modifier une constante\n</code></pre> <p>Le mot-cl\u00e9 <code>var</code> est d\u00e9pr\u00e9ci\u00e9 et ne devrait pas \u00eatre utilis\u00e9. Il est pr\u00e9f\u00e9rable d'utiliser <code>let</code> ou <code>const</code> pour d\u00e9clarer des variables. En effet, <code>var</code> a des comportements inattendus et peut causer des probl\u00e8mes puisqu'il ne respecte pas la port\u00e9e lexicale. Par exemple, le code suivant ne g\u00e9n\u00e8re pas d'erreur :</p> <pre><code>if (true) {\n  var a = 1;\n}\n// La variable a est encore accessible en dehors du bloc if\nconsole.log(a); // 1\n</code></pre> <p>Alors que le code suivant g\u00e9n\u00e8re une erreur :</p> <pre><code>if (true) {\n  let b = 2;\n}\n// La variable b n'est pas accessible en dehors du bloc if\nconsole.log(b); // Erreur : b is not defined\n</code></pre>"},{"location":"semaine_02/theorie/les_bases/#portee-des-variables","title":"Port\u00e9e des variables","text":"<p>En JavaScript, il existe trois types de port\u00e9e pour les variables : la port\u00e9e globale, la port\u00e9e de fonction et la port\u00e9e de bloc. Une variable d\u00e9clar\u00e9e \u00e0 l'ext\u00e9rieur d'une fonction est une variable globale, tandis qu'une variable d\u00e9clar\u00e9e \u00e0 l'int\u00e9rieur d'une fonction est une variable locale. Une variable d\u00e9clar\u00e9e \u00e0 l'int\u00e9rieur d'un bloc (par exemple, un <code>if</code> ou une boucle <code>for</code>) est une variable locale au bloc.</p> <pre><code>let x = 1; // variable globale\n\nfunction test() {\n  let y = 2; // variable locale\n  for (let i = 0; i &lt; 3; i++) {\n    let z = 3; // variable locale au bloc\n    console.log(i);\n  }\n  console.log(x); // 1\n  console.log(y); // 2\n  // Ici, console.log(z) serait une erreur\n}\n\ntest();\nconsole.log(x); // 1\nconsole.log(y); // Erreur : y is not defined\n</code></pre>"},{"location":"semaine_02/theorie/les_bases/#types-de-donnees","title":"Types de donn\u00e9es","text":"<p>JavaScript est un langage de programmation dynamiquement typ\u00e9, ce qui signifie que les variables n'ont pas de type fixe. Les types de donn\u00e9es en JavaScript sont les suivants :</p> <ul> <li><code>number</code> : nombres entiers ou d\u00e9cimaux</li> <li><code>string</code> : cha\u00eenes de caract\u00e8res</li> <li><code>boolean</code> : valeurs <code>true</code> ou <code>false</code></li> <li><code>null</code> : valeur nulle</li> <li><code>undefined</code> : valeur non d\u00e9finie</li> <li><code>object</code> : objets, tableaux, fonctions, etc.</li> </ul> <pre><code>let a = 1; // number\nlet b = \"Hello\"; // string\nlet c = true; // boolean\nlet d = null; // null\nlet e; // undefined\nlet f = { x: 1, y: 2 }; // object\nlet g = [1, 2, 3]; // object (tableau)\nlet h = function() {}; // object (fonction)\n</code></pre>"},{"location":"semaine_02/theorie/les_bases/#operateurs","title":"Op\u00e9rateurs","text":"<p>Les op\u00e9rateurs en JavaScript sont similaires \u00e0 ceux des autres langages de programmation. Voici quelques exemples d'op\u00e9rateurs :</p> <ul> <li>Op\u00e9rateurs arithm\u00e9tiques : <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code></li> <li>Op\u00e9rateurs de comparaison : <code>==</code>, <code>===</code>, <code>!=</code>, <code>!==</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code></li> <li>Op\u00e9rateurs logiques : <code>&amp;&amp;</code>, <code>||</code>, <code>!</code></li> </ul> <p>La diff\u00e9rence entre <code>==</code> et <code>===</code> est que <code>==</code> compare les valeurs sans tenir compte du type, tandis que <code>===</code> compare les valeurs en tenant compte du type.</p> <pre><code>let a = 1;\nlet b = \"1\";\n\nconsole.log(a == b); // true\nconsole.log(a === b); // false\n</code></pre>"},{"location":"semaine_02/theorie/les_bases/#structures-de-controle","title":"Structures de contr\u00f4le","text":"<p>Les structures de contr\u00f4le en JavaScript sont similaires \u00e0 celles des autres langages de programmation. Voici quelques exemples de structures de contr\u00f4le :</p> <ul> <li><code>if</code>, <code>else if</code>, <code>else</code> : pour ex\u00e9cuter du code conditionnel</li> <li><code>switch</code>, <code>case</code>, <code>default</code> : pour ex\u00e9cuter du code en fonction de la valeur   d'une variable</li> <li><code>for</code>, <code>while</code>, <code>do while</code> : pour ex\u00e9cuter du code de mani\u00e8re r\u00e9p\u00e9t\u00e9e</li> </ul> <pre><code>let x = 1;\n\nif (x === 1) {\n  console.log(\"x est \u00e9gal \u00e0 1\");\n} else if (x === 2) {\n  console.log(\"x est \u00e9gal \u00e0 2\");\n} else {\n  console.log(\"x n'est ni \u00e9gal \u00e0 1 ni \u00e0 2\");\n}\n\nswitch (x) {\n  case 1:\n    console.log(\"x est \u00e9gal \u00e0 1\");\n    break;\n  case 2:\n    console.log(\"x est \u00e9gal \u00e0 2\");\n    break;\n  case 3:\n  case 4:\n    console.log(\"x est \u00e9gal \u00e0 3 ou 4\");\n    break;\n  default:\n    console.log(\"x n'est ni \u00e9gal \u00e0 1 ni \u00e0 2\");\n}\n\nfor (let i = 0; i &lt; 3; i++) {\n  console.log(i);\n}\n\nlet j = 0;\nwhile (j &lt; 3) {\n  console.log(j);\n  j++;\n}\n\nlet k = 0;\ndo {\n  console.log(k);\n  k++;\n} while (k &lt; 3);\n</code></pre> <p>Dans le cas du <code>switch</code>, il est important d'utiliser le mot-cl\u00e9 <code>break</code> pour sortir du <code>switch</code> une fois qu'un <code>case</code> a \u00e9t\u00e9 ex\u00e9cut\u00e9. Sinon, tous les <code>case</code> suivants seront ex\u00e9cut\u00e9s.</p> <p>Pour parcourir un objet, on peut utiliser une boucle <code>for...in</code> :</p> <p><pre><code>let obj = { x: 1, y: 2, z: 3 };\n\nfor (let key in obj) {\n  console.log(key + \": \" + obj[key]);\n}\n</code></pre> L'ordre des cl\u00e9s n'est pas garanti, il est donc possible que les cl\u00e9s ne soient pas affich\u00e9es dans l'ordre dans lequel elles ont \u00e9t\u00e9 d\u00e9finies.</p> <p>Pour parcourir un tableau, on peut utiliser une boucle <code>for...of</code> :</p> <pre><code>let arr = [1, 2, 3];\n\nfor (let value of arr) {\n  console.log(value);\n}\n</code></pre> <p>\u00c0 noter que si vous <code>for...of</code> sur un objet, vous obtiendrez une erreur. Si vous utilisez <code>for...in</code> sur un tableau, vous obtiendrez les index du tableau.</p>"},{"location":"semaine_02/theorie/les_bases/#gestions-des-erreurs","title":"Gestions des erreurs","text":"<p>En JavaScript, les erreurs peuvent \u00eatre g\u00e9r\u00e9es \u00e0 l'aide de blocs <code>try</code>, <code>catch</code> et <code>finally</code>. Le bloc <code>try</code> permet d'essayer d'ex\u00e9cuter du code qui pourrait g\u00e9n\u00e9rer une erreur. Si une erreur est g\u00e9n\u00e9r\u00e9e, le bloc <code>catch</code> permet de la capturer et de la g\u00e9rer. Le bloc <code>finally</code> permet d'ex\u00e9cuter du code apr\u00e8s le bloc <code>try</code> et le bloc <code>catch</code>, qu'une erreur ait \u00e9t\u00e9 g\u00e9n\u00e9r\u00e9e ou non.</p> <pre><code>try {\n  // Code qui pourrait g\u00e9n\u00e9rer une erreur\n  throw new Error(\"Une erreur s'est produite !\");\n} catch (err) {\n  // Gestion de l'erreur\n  console.error(err);\n} finally {\n  // Code \u00e0 ex\u00e9cuter apr\u00e8s le bloc try et le bloc catch\n  console.log(\"Fin du bloc try-catch\");\n}\n</code></pre>"},{"location":"semaine_02/theorie/objets_tableaux/","title":"Objets et tableaux","text":"<p>Les objets et les tableaux permettent de stocker des collections de donn\u00e9es de mani\u00e8re structur\u00e9e.</p>"},{"location":"semaine_02/theorie/objets_tableaux/#objets","title":"Objets","text":"<p>Les objets en JavaScript sont des collections de paires cl\u00e9-valeur. Voici comment d\u00e9clarer un objet en JavaScript :</p> <pre><code>let person = {\n  firstName: 'John',\n  lastName: 'Doe',\n  age: 30,\n  isStudent: true\n};\n\nconsole.log(person.firstName); // John\nconsole.log(person['lastName']); // Doe\n</code></pre> <p>Il est possible d'ajouter ou de modifier des propri\u00e9t\u00e9s d'un objet apr\u00e8s sa d\u00e9claration :</p> <pre><code>person.city = 'Montreal';\nperson['country'] = 'Canada';\n\nconsole.log(person.city); // Montreal\nconsole.log(person['country']); // Canada\n</code></pre> <p>La syntaxe <code>person.firstName</code> est \u00e9quivalente \u00e0 <code>person['firstName']</code>. Noter aussi que les cl\u00e9s des propri\u00e9t\u00e9s d'un objet sont des cha\u00eenes de caract\u00e8res. Il est possible d'utiliser des caract\u00e8res sp\u00e9ciaux, des espaces et des chiffres dans les cl\u00e9s :</p> <pre><code>let person = {\n  'first name': 'John',\n  'last-name': 'Doe',\n  'age': 30\n};\n\nconsole.log(person['first name']); // John\nconsole.log(person['last-name']); // Doe\n</code></pre> <p>Les objets peuvent contenir d'autres objets ou des tableaux :</p> <pre><code>let person = {\n  name: {\n    first: 'John',\n    last: 'Doe'\n  },\n  age: 30,\n  hobbies: ['reading', 'swimming']\n};\n\nconsole.log(person.name.first); // John\nconsole.log(person.hobbies[0]); // reading\n</code></pre>"},{"location":"semaine_02/theorie/objets_tableaux/#suppression-de-proprietes","title":"Suppression de propri\u00e9t\u00e9s","text":"<p>Il est possible de supprimer une propri\u00e9t\u00e9 d'un objet avec l'op\u00e9rateur <code>delete</code> :</p> <pre><code>let person = {\n  firstName: 'John',\n  lastName: 'Doe',\n  age: 30,\n  isStudent: true\n};\n\ndelete person.age;\n\nconsole.log(person.age); // undefined\n</code></pre>"},{"location":"semaine_02/theorie/objets_tableaux/#constructeurs-et-heritage","title":"Constructeurs et h\u00e9ritage","text":"<p>En JavaScript, la programmation orient\u00e9e objet repose sur le concept de prototypes. Toutefois, il existe depuis ECMAScript 2015 (ES6) une syntaxe bas\u00e9e sur les classes, qui rend la manipulation des objets et de l\u2019h\u00e9ritage plus famili\u00e8re pour ceux qui connaissent d\u2019autres langages orient\u00e9s objet (Java, C++, etc.).</p>"},{"location":"semaine_02/theorie/objets_tableaux/#les-fonctions-constructrices-et-le-prototype","title":"Les fonctions constructrices et le prototype","text":"<p>Avant l\u2019introduction des classes ES6, la cr\u00e9ation d\u2019objets \"comme des classes\" en JavaScript se faisait \u00e0 l\u2019aide de fonctions constructrices. L\u2019id\u00e9e est de cr\u00e9er une fonction qu\u2019on va appeler avec le mot-cl\u00e9 <code>new</code> pour instancier un objet.</p> <pre><code>function Person(nom, age) {\n  // Dans une fonction constructrice, \"this\" fait r\u00e9f\u00e9rence \u00e0 l\u2019instance en cours de cr\u00e9ation\n  this.nom = nom;\n  this.age = age;\n\n  // Il est possible de d\u00e9finir des m\u00e9thodes directement ici...\n  this.sePresenter = function() {\n    console.log(`Bonjour, je m'appelle ${this.nom} et j'ai ${this.age} ans.`);\n  };\n}\n\n// Instanciation d'un objet \"Person\"\nconst alice = new Person(\"Alice\", 25);\nalice.sePresenter(); \n// Affiche : \"Bonjour, je m'appelle Alice et j'ai 25 ans.\"\n</code></pre> <p>Donc, dans l\u2019exemple ci-dessus, <code>Person</code> est une fonction constructrice qui permet de cr\u00e9er des objets <code>Person</code>. Lorsqu\u2019on appelle <code>new Person(\"Alice\", 25)</code>, une nouvelle instance de <code>Person</code> est cr\u00e9\u00e9e avec les propri\u00e9t\u00e9s <code>nom</code> et <code>age</code> initialis\u00e9es \u00e0 \"Alice\" et 25, respectivement.</p> <p>Sans le mot-cl\u00e9 <code>new</code>, <code>this</code> fait r\u00e9f\u00e9rence \u00e0 l\u2019objet global (<code>window</code> dans un navigateur, <code>global</code> dans Node.js). C\u2019est pourquoi il est important d\u2019utiliser <code>new</code> lors de l\u2019instanciation d\u2019un objet avec une fonction constructrice.</p> <p>Aussi, pour \u00e9viter de dupliquer les m\u00e9thodes pour chaque instance, il est possible de les d\u00e9finir sur le prototype de la fonction constructrice :</p> <pre><code>function Person(nom, age) {\n  this.nom = nom;\n  this.age = age;\n}\n\nPerson.prototype.sePresenter = function() {\n  console.log(`Bonjour, je m'appelle ${this.nom} et j'ai ${this.age} ans.`);\n};\n\nconst alice = new Person(\"Alice\", 25);\nalice.sePresenter();\n// Affiche : \"Bonjour, je m'appelle Alice et j'ai 25 ans.\"\n</code></pre> <p>Dans cet exemple, la m\u00e9thode <code>sePresenter</code> est d\u00e9finie sur <code>Person.prototype</code>. Cela signifie que toute instance de Person h\u00e9ritera de cette m\u00e9thode via la cha\u00eene de prototypes. On a ainsi une seule fonction en m\u00e9moire, partag\u00e9e par tous les objets cr\u00e9\u00e9s.</p>"},{"location":"semaine_02/theorie/objets_tableaux/#les-classes-es6","title":"Les classes ES6","text":"<p>Depuis ECMAScript 2015 (ES6), JavaScript supporte une syntaxe de classe plus proche de ce qu\u2019on retrouve dans d\u2019autres langages orient\u00e9s objet. Voici comment on pourrait r\u00e9\u00e9crire l\u2019exemple pr\u00e9c\u00e9dent avec des classes :</p> <pre><code>class Person {\n  constructor(nom, age) {\n    this.nom = nom;\n    this.age = age;\n  }\n\n  sePresenter() {\n    console.log(`Bonjour, je m'appelle ${this.nom} et j'ai ${this.age} ans.`);\n  }\n}\n\nconst alice = new Person(\"Alice\", 25);\nalice.sePresenter();\n// Affiche : \"Bonjour, je m'appelle Alice et j'ai 25 ans.\"\n</code></pre> <p>Le constructeur de la classe est d\u00e9fini avec le mot-cl\u00e9 <code>constructor</code>. Il est appel\u00e9 lorsqu\u2019on instancie un nouvel objet avec <code>new</code>. Les m\u00e9thodes de la classe sont d\u00e9finies directement dans le corps de la classe, sans le mot-cl\u00e9 <code>function</code>. Elles sont automatiquement ajout\u00e9es au prototype de la classe.</p> <p>Les deux approches (fonctions constructrices et classes) sont \u00e9quivalentes en termes de fonctionnalit\u00e9s. C\u2019est une question de pr\u00e9f\u00e9rence de style et de lisibilit\u00e9.</p>"},{"location":"semaine_02/theorie/objets_tableaux/#heritage","title":"H\u00e9ritage","text":"<p>Cette section est une introduction \u00e0 l\u2019h\u00e9ritage en JavaScript avec la syntaxe des classes ES6. Pour une discussion plus approfondie sur les prototypes et l\u2019h\u00e9ritage en JavaScript, voir MDN Web Docs.</p> <p>En JavaScript, l\u2019h\u00e9ritage est bas\u00e9 sur les prototypes. Une classe peut h\u00e9riter des propri\u00e9t\u00e9s et m\u00e9thodes d\u2019une autre classe en utilisant le mot-cl\u00e9 <code>extends</code>.</p> <pre><code>class Person {\n  constructor(nom, age) {\n    this.nom = nom;\n    this.age = age;\n  }\n\n  sePresenter() {\n    console.log(`Bonjour, je m'appelle ${this.nom} et j'ai ${this.age} ans.`);\n  }\n}\n\nclass Etudiant extends Person {\n  constructor(nom, age, programme) {\n    super(nom, age); // Appel du constructeur de la classe parent\n    this.programme = programme;\n  }\n\n  etudier() {\n    console.log(`${this.nom} \u00e9tudie ${this.programme}.`);\n  }\n}\n\nconst bob = new Etudiant(\"Bob\", 20, \"Informatique\");\nbob.sePresenter();\nbob.etudier();\n// Affiche :\n// \"Bonjour, je m'appelle Bob et j'ai 20 ans.\"\n// \"Bob \u00e9tudie Informatique.\"\n</code></pre> <p>Dans cet exemple, <code>Etudiant</code> h\u00e9rite de <code>Person</code> en utilisant <code>extends</code>. Le constructeur de <code>Etudiant</code> appelle <code>super(nom, age)</code> pour appeler le constructeur de la classe parent <code>Person</code>. Les m\u00e9thodes <code>sePresenter</code> et <code>etudier</code> sont disponibles pour les instances de <code>Etudiant</code>.</p> <p>Il est possible de surcharger des m\u00e9thodes h\u00e9rit\u00e9es en red\u00e9finissant la m\u00e9thode dans la classe enfant. Par exemple, si <code>Etudiant</code> red\u00e9finit <code>sePresenter</code>, la m\u00e9thode de <code>Person</code> ne sera pas appel\u00e9e pour les instances de <code>Etudiant</code>.</p>"},{"location":"semaine_02/theorie/objets_tableaux/#tableaux","title":"Tableaux","text":"<p>Les tableaux en JavaScript sont des collections ordonn\u00e9es d'\u00e9l\u00e9ments. Voici comment d\u00e9clarer un tableau en JavaScript :</p> <pre><code>let numbers = [1, 2, 3, 4, 5];\n\nconsole.log(numbers[0]); // 1\nconsole.log(numbers[2]); // 3\n</code></pre> <p>Il est possible d'ajouter ou de modifier des \u00e9l\u00e9ments d'un tableau apr\u00e8s sa d\u00e9claration :</p> <pre><code>numbers.push(6);\nnumbers[1] = 10;\n\nconsole.log(numbers); // [1, 10, 3, 4, 5, 6]\n</code></pre>"},{"location":"semaine_02/theorie/objets_tableaux/#parcourir-un-tableau","title":"Parcourir un tableau","text":"<p>Il est possible de parcourir un tableau avec une boucle <code>for</code> :</p> <pre><code>let numbers = [1, 2, 3, 4, 5];\n\nfor (let i = 0; i &lt; numbers.length; i++) {\n  console.log(numbers[i]);\n}\n</code></pre> <p>Il est aussi possible d'utiliser la m\u00e9thode <code>forEach</code> :</p> <pre><code>numbers.forEach(function(number) {\n  console.log(number);\n});\n</code></pre>"},{"location":"semaine_02/theorie/objets_tableaux/#la-methode-splice","title":"La m\u00e9thode <code>splice</code>","text":"<p>La m\u00e9thode <code>splice</code> permet de modifier le contenu d'un tableau en ajoutant ou en supprimant des \u00e9l\u00e9ments. La m\u00e9thode <code>splice</code> prend plusieurs arguments : l'index de d\u00e9part, le nombre d'\u00e9l\u00e9ments \u00e0 supprimer et les \u00e9l\u00e9ments \u00e0 ajouter.</p> <p>Par exemple, pour ajouter un \u00e9l\u00e9ment \u00e0 un tableau :</p> <pre><code>let numbers = [1, 2, 3, 4, 5];\n\nnumbers.splice(2, 0, 6); // Ajoute l'\u00e9l\u00e9ment 6 \u00e0 l'index 2\n\nconsole.log(numbers); // [1, 2, 6, 3, 4, 5]\n</code></pre> <p>Pour supprimer un \u00e9l\u00e9ment d'un tableau :</p> <pre><code>let numbers = [1, 2, 3, 4, 5];\n\nnumbers.splice(2, 1); // Supprime l'\u00e9l\u00e9ment \u00e0 l'index 2\n\nconsole.log(numbers); // [1, 2, 4, 5]\n</code></pre> <p>Il est possible de supprimer et d'ajouter des \u00e9l\u00e9ments en m\u00eame temps :</p> <pre><code>let numbers = [1, 2, 3, 4, 5];\n\n// Supprime l'\u00e9l\u00e9ment \u00e0 l'index 2 et ajoute deux \u00e9l\u00e9ments\nnumbers.splice(2, 1, 6, 7);\n\nconsole.log(numbers); // [1, 2, 6, 7, 4, 5]\n</code></pre>"},{"location":"semaine_02/theorie/objets_tableaux/#copie-de-tableaux","title":"Copie de tableaux","text":"<p>Il est important de noter que l'affectation d'un tableau \u00e0 une autre variable ne copie pas le tableau, mais cr\u00e9e une r\u00e9f\u00e9rence au m\u00eame tableau. Pour copier un tableau, il est possible d'utiliser la m\u00e9thode <code>slice</code> :</p> <pre><code>let numbers = [1, 2, 3, 4, 5];\nlet copy = numbers.slice();\n\ncopy.push(6);\n\nconsole.log(numbers); // [1, 2, 3, 4, 5]\nconsole.log(copy); // [1, 2, 3, 4, 5, 6]\n</code></pre> <p>La m\u00e9thode <code>slice</code> sans arguments cr\u00e9e une copie du tableau original. Si on fournit des arguments \u00e0 <code>slice</code>, on obtient une sous-section du tableau original.</p> <pre><code>let numbers = [1, 2, 3, 4, 5];\n\nlet subArray = numbers.slice(1, 3);\n\nconsole.log(subArray); // [2, 3]\n</code></pre>"},{"location":"semaine_02/theorie/objets_tableaux/#operateurs-de-decomposition","title":"Op\u00e9rateurs de d\u00e9composition","text":"<p>L'op\u00e9rateur de d\u00e9composition (<code>spread operator</code>) permet de d\u00e9composer un tableau en \u00e9l\u00e9ments individuels. Cela peut \u00eatre utile pour passer les \u00e9l\u00e9ments d'un tableau comme arguments \u00e0 une fonction :</p> <pre><code>let numbers = [1, 2, 3];\n\nfunction sum(a, b, c) {\n  return a + b + c;\n}\n\nconsole.log(sum(...numbers)); // 6\n</code></pre> <p>Il est aussi possible de concat\u00e9ner des tableaux avec l'op\u00e9rateur de d\u00e9composition :</p> <pre><code>let arr1 = [1, 2, 3];\nlet arr2 = [4, 5, 6];\n\nlet combined = [...arr1, ...arr2];\n\nconsole.log(combined); // [1, 2, 3, 4, 5, 6]\n</code></pre>"}]}